<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>View My Connections</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 50px auto;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        h1 { color: #4CAF50; }
        .connection-card {
            background: #2a2a2a;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }
        .connection-card.duplicate {
            border-left-color: #ff9800;
            opacity: 0.7;
        }
        .platform {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .status.active { background: #4CAF50; color: white; }
        .status.duplicate { background: #ff9800; color: white; }
        .info { color: #888; font-size: 14px; }
        button {
            background: #f44336;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 5px 0 0;
        }
        button:hover { background: #d32f2f; }
        button.primary {
            background: #4CAF50;
        }
        button.primary:hover { background: #45a049; }
        .output {
            background: #1a1a1a;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #ff9800; }
        .summary {
            background: #333;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 4px solid #2196F3;
        }
    </style>
</head>
<body>
    <h1>üîç Your OAuth Connections</h1>
    <p>Real-time view of all your platform connections</p>

    <button class="primary" onclick="loadConnections()">üîÑ Refresh Connections</button>
    <button class="primary" onclick="cleanupDuplicates()">üßπ Clean Up Duplicates</button>

    <div id="summary" class="summary"></div>
    <div id="connections"></div>
    <div id="output" class="output"></div>

    <script>
        const API_URL = 'https://autorepost-api-l4oy.onrender.com/api';
        const EMAIL = 'justin@justinkratz.com';
        const PASSWORD = 'Justin123456';
        let token = null;
        let connections = [];

        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'success' ? 'success' : type === 'error' ? 'error' : type === 'warning' ? 'warning' : '';
            output.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
            output.scrollTop = output.scrollHeight;
        }

        async function login() {
            try {
                const response = await fetch(`${API_URL}/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email: EMAIL, password: PASSWORD })
                });

                if (!response.ok) {
                    throw new Error(`Login failed: ${response.statusText}`);
                }

                const data = await response.json();
                token = data.accessToken;
                return data.user;
            } catch (error) {
                log(`‚ùå Login failed: ${error.message}`, 'error');
                throw error;
            }
        }

        async function loadConnections() {
            log('üîÑ Loading connections...');

            try {
                const user = await login();
                log('‚úÖ Logged in successfully', 'success');

                const response = await fetch(
                    `${API_URL}/connections?tenantId=${user.tenantId}&userId=${user.id}`,
                    {
                        headers: { 'Authorization': `Bearer ${token}` }
                    }
                );

                if (!response.ok) {
                    throw new Error(`Failed to fetch connections: ${response.statusText}`);
                }

                connections = await response.json();
                log(`‚úÖ Found ${connections.length} total connections`, 'success');

                displayConnections();
            } catch (error) {
                log(`‚ùå Error: ${error.message}`, 'error');
            }
        }

        function displayConnections() {
            // Group by platform
            const grouped = connections.reduce((acc, conn) => {
                if (!acc[conn.platform]) acc[conn.platform] = [];
                acc[conn.platform].push(conn);
                return acc;
            }, {});

            // Display summary
            const summary = document.getElementById('summary');
            summary.innerHTML = `
                <h2>üìä Summary</h2>
                <p><strong>Total Connections:</strong> ${connections.length}</p>
                <p><strong>Platforms Connected:</strong> ${Object.keys(grouped).length}</p>
                <ul>
                    ${Object.entries(grouped).map(([platform, conns]) => `
                        <li>${getPlatformIcon(platform)} <strong>${platform}</strong>: ${conns.length} connection(s)
                            ${conns.length > 1 ? '<span class="status duplicate">DUPLICATES</span>' : ''}
                        </li>
                    `).join('')}
                </ul>
            `;

            // Display individual connections
            const container = document.getElementById('connections');
            container.innerHTML = '<h2>üîó All Connections</h2>';

            Object.entries(grouped).forEach(([platform, conns]) => {
                // Sort by creation date (newest first)
                conns.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

                conns.forEach((conn, index) => {
                    const isDuplicate = index > 0; // First one is kept, rest are duplicates
                    const card = document.createElement('div');
                    card.className = 'connection-card' + (isDuplicate ? ' duplicate' : '');
                    card.innerHTML = `
                        <div class="platform">${getPlatformIcon(platform)} ${platform}</div>
                        <span class="status ${conn.status.toLowerCase()}">${conn.status}</span>
                        ${isDuplicate ? '<span class="status duplicate">DUPLICATE</span>' : ''}
                        <p><strong>Account:</strong> ${conn.accountDisplayName} (@${conn.accountHandle})</p>
                        <p class="info">Connected: ${new Date(conn.createdAt).toLocaleString()}</p>
                        <p class="info">Last Synced: ${conn.lastSyncedAt ? new Date(conn.lastSyncedAt).toLocaleString() : 'Never'}</p>
                        <p class="info">ID: ${conn.id}</p>
                        ${isDuplicate ? `<button onclick="deleteConnection('${conn.id}')">üóëÔ∏è Delete Duplicate</button>` : ''}
                    `;
                    container.appendChild(card);
                });
            });
        }

        function getPlatformIcon(platform) {
            const icons = {
                'YOUTUBE': '‚ñ∂Ô∏è',
                'TWITTER': 'üê¶',
                'INSTAGRAM': 'üì∏',
                'TIKTOK': 'üéµ'
            };
            return icons[platform] || 'üîó';
        }

        async function deleteConnection(connectionId) {
            if (!confirm('Are you sure you want to delete this connection?')) {
                return;
            }

            log(`üóëÔ∏è Deleting connection ${connectionId}...`);

            try {
                const response = await fetch(`${API_URL}/connections/${connectionId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (!response.ok) {
                    throw new Error(`Delete failed: ${response.statusText}`);
                }

                log(`‚úÖ Connection deleted successfully`, 'success');
                await loadConnections(); // Reload to show updated list
            } catch (error) {
                log(`‚ùå Error deleting connection: ${error.message}`, 'error');
            }
        }

        async function cleanupDuplicates() {
            log('üßπ Cleaning up duplicate connections...');

            const grouped = connections.reduce((acc, conn) => {
                if (!acc[conn.platform]) acc[conn.platform] = [];
                acc[conn.platform].push(conn);
                return acc;
            }, {});

            let deletedCount = 0;

            for (const [platform, conns] of Object.entries(grouped)) {
                if (conns.length > 1) {
                    // Sort by creation date (newest first)
                    conns.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

                    // Delete all except the first (newest)
                    for (let i = 1; i < conns.length; i++) {
                        try {
                            const response = await fetch(`${API_URL}/connections/${conns[i].id}`, {
                                method: 'DELETE',
                                headers: { 'Authorization': `Bearer ${token}` }
                            });

                            if (response.ok) {
                                log(`‚úÖ Deleted duplicate ${platform} connection`, 'success');
                                deletedCount++;
                            } else {
                                log(`‚ö†Ô∏è Failed to delete ${platform} connection`, 'warning');
                            }
                        } catch (error) {
                            log(`‚ùå Error deleting ${platform}: ${error.message}`, 'error');
                        }
                    }
                }
            }

            log(`üéâ Cleanup complete! Deleted ${deletedCount} duplicate(s)`, 'success');
            await loadConnections(); // Reload to show cleaned list
        }

        // Auto-load on page load
        window.addEventListener('load', () => {
            loadConnections();
        });
    </script>
</body>
</html>
